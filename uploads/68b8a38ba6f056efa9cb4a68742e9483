from fastapi import FastAPI, UploadFile, File
from fastapi.responses import FileResponse
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.exceptions import InvalidSignature
import hashlib
import qrcode
import fitz
import io

app = FastAPI()

# Generate key pair
def generate_key_pair():
    private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
    public_key = private_key.public_key()
    return private_key, public_key

# Sign document
def sign_document(private_key, document_data):
    document_hash = hashlib.sha256(document_data).digest()
    signature = private_key.sign(document_hash, ec.ECDSA(hashes.SHA256()))
    return signature

# Generate QR code
def generate_qr_code(signature, public_key):
    signature_str = signature.hex()
    public_key_str = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    ).decode()

    data = f"Signature: {signature_str}\nPublic Key: {public_key_str}"
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    qr.add_data(data)
    qr.make(fit=True)
    img = qr.make_image(fill_color="black", back_color="white")

    qr_code_path = "signature_qr_code.png"
    img.save(qr_code_path)
    return qr_code_path

# Write QR code to document
def write_header(document_data, qr_code_path):
    image_rectangle = fitz.Rect(450, 20, 550, 120)
    file_handle = fitz.open("pdf", document_data)
    first_page = file_handle[0]

    first_page.insert_image(image_rectangle, filename=qr_code_path)
    pdf_bytes = file_handle.write()
    return pdf_bytes

# Verify signature
def verify_signature(public_key, document_data, signature):
    document_hash = hashlib.sha256(document_data).digest()
    try:
        public_key.verify(signature, document_hash, ec.ECDSA(hashes.SHA256()))
        return True
    except InvalidSignature:
        return False

@app.post("/generate_keys")
def generate_keys():
    private_key, public_key = generate_key_pair()
    private_key_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption()
    ).decode()
    public_key_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    ).decode()
    return {"private_key": private_key_pem, "public_key": public_key_pem}

@app.post("/sign_document")
async def sign_doc(file: UploadFile = File(...), private_key: str = ""):
    private_key = serialization.load_pem_private_key(
        private_key.encode(), password=None, backend=default_backend()
    )
    document_data = await file.read()
    signature = sign_document(private_key, document_data)
    qr_code_path = generate_qr_code(signature, private_key.public_key())
    signed_pdf = write_header(document_data, qr_code_path)
    return FileResponse(io.BytesIO(signed_pdf), media_type='application/pdf', filename="signed_document.pdf")

@app.post("/verify_document")
async def verify_doc(file: UploadFile = File(...), public_key: str = "", signature: str = ""):
    public_key = serialization.load_pem_public_key(
        public_key.encode(), backend=default_backend()
    )
    document_data = await file.read()
    signature_bytes = bytes.fromhex(signature)
    is_valid = verify_signature(public_key, document_data, signature_bytes)
    return {"is_valid": is_valid}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
